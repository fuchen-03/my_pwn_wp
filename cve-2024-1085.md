# 【kernel exploit】CVE-2023-6811 nft_set_elem对象UAF漏洞利用

**影响版本**：5.15.134 - 5.15.147 ； 6.1.56 - 6.1.74    需要`CAP_NET_ADMIN` 和 User namespace。

**测试版本**：Linux-6.1.70

**编译选项**：

**CONFIG_NFT_CT=y**  （注册 `NFT_OBJECT_CT_EXPECT` 类型的object，被漏洞set element所引用）  依赖 **CONFIG_NF_DEFRAG_IPV4  /  CONFIG_NF_DEFRAG_IPV6**   /  **CONFIG_NF_CONNTRACK**  （命令`$ modinfo ./nft_ct.ko`）前三个模块是利用的exp需要的模块

**CONFIG_NETFILTER=y**      **CONFIG_NF_TABLES=y**

**CONFIG_BINFMT_MISC=y** （否则启动VM时报错）

在编译时将`.config`中的`CONFIG_E1000`和`CONFIG_E1000E`，变更为=y。

**漏洞描述**：在函数`nft_setelem_catchall_deactivate`中，它只检查元素当前代际是否活跃

```c
...
list_for_each_entry(catchall, &set->catchall_list, list) {
		ext = nft_set_elem_ext(set, catchall->elem);
		if (!nft_is_active(net, ext))
			continue;
...
```

但是它没有使用函数`nft_is_active_next`检查元素在下一代际是否活跃，这可能导致同一个catchall元素被释放两次

## Background

gencursor定义了两个代际：当前活动的和下一个。通过1-bit游标（gencursor）在0/1之间循环切换，形成双代际环形缓冲区（经过调试观察，gencursor的值一直为0，只是会在定义的宏里变换代际）

```c
struct net{
    ...
        struct netns_nftables	nft;
    ...
}
struct netns_nftables{
    u8 gencursor; // 00
}
```

对象包含一个两位的位掩码，指定它们在这些代际中的活跃状态。置位表示在对应代际中不活跃。新对象开始时在当前代际不活跃，在下一代际活跃。提交规则集时，位掩码被清除，表示在所有代际中活跃。删除对象时，它被设置为在下一代际不活跃。提交后，对象被移除。

```c
struct nft_set_ext{
    u8 genmask;
    u8 offset[9];
    char data[];
}
```

熟悉关于代际的定义宏

```c
static inline unsigned int nft_gencursor_next(const struct net *net)
{
	return net->nft.gencursor + 1 == 1 ? 1 : 0;
}

static inline u8 nft_genmask_next(const struct net *net)
{
	return 1 << nft_gencursor_next(net);
}

static inline u8 nft_genmask_cur(const struct net *net)
{
	/* Use READ_ONCE() to prevent refetching the value for atomicity */
	return 1 << READ_ONCE(net->nft.gencursor);
}
/* Check if this object is currently active. */
#define nft_is_active(__net, __obj)				\
	(((__obj)->genmask & nft_genmask_cur(__net)) == 0)

/* Check if this object is active in the next generation. */
#define nft_is_active_next(__net, __obj)			\
	(((__obj)->genmask & nft_genmask_next(__net)) == 0)

/* This object becomes active in the next generation. */
#define nft_activate_next(__net, __obj)				\
	(__obj)->genmask = nft_genmask_cur(__net)

/* This object becomes inactive in the next generation. */
#define nft_deactivate_next(__net, __obj)			\
        (__obj)->genmask = nft_genmask_next(__net)

/* After committing the ruleset, clear the stale generation bit. */
#define nft_clear(__net, __obj)					\
	(__obj)->genmask &= ~nft_genmask_next(__net)
#define nft_active_genmask(__obj, __genmask)			\
	!((__obj)->genmask & __genmask)
```

当创建一个setelem时，`ext->genmask = nft_genmask_cur = 01(bit)`，应该是在经过一次`nf_tables_commit`之后他的genmask就变成了`00(bit)`。

```c
case NFT_MSG_NEWSETELEM:
			te = (struct nft_trans_elem *)trans->data;

			nft_setelem_activate(net, te->set, &te->elem);
			nf_tables_setelem_notify(&trans->ctx, te->set,
						 &te->elem,
						 NFT_MSG_NEWSETELEM);
			if (te->set->ops->commit &&
			    list_empty(&te->set->pending_update)) {
				list_add_tail(&te->set->pending_update,
					      &set_update_list);
			}
			nft_trans_destroy(trans);
			break;

static void nft_setelem_activate(struct net *net, struct nft_set *set,
				 struct nft_set_elem *elem)
{
	struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);

	if (nft_setelem_is_catchall(set, elem)) {
		nft_set_elem_change_active(net, set, ext);
	} else {
		set->ops->activate(net, set, elem);
	}
}

static inline void nft_set_elem_change_active(const struct net *net,
					      const struct nft_set *set,
					      struct nft_set_ext *ext)
{
	ext->genmask ^= nft_genmask_next(net);
}
01^01=00
```

然后第一次delete时，首先验证`nft_is_active(net,ext); ext->genmask(00)&nft_genmask_cur(01)==0`，所以该对象是活跃的，然后在进行`nft_set_elem_change_active; ext->genmask(00)^=nft_genmask_next(10) = 10`；

第二次delete时，验证`nft_is_active(net,ext); ext->genmask(10)&nft_genmask_cur(01)==0`，仍然能通过进行第二次释放，所以必须要再增加一道检查`nft_is_active_next(net,ext); ext->genmask(10)&nft_genmask_cur(10)!=0`无法通过检查，不能进行释放



## 思路

### 信息泄露

1、创建一个`pipapo`类型集合A，再创建一个`catchall elem B`在集合A中

2、两次delete`elem B`，两次中间再释放另一个堆，防止DF报错，这样就可以申请两次使得两个堆指向同一块区域

3、堆喷`nft_table->udata`占据`elem B`，然后遍历table，会找到两个内容相同的table，定义为`table C、table D`

4、释放`table C`

5、堆喷`nft_bitmap_elem`占据`table C`，在`elem`中设置`NFTA_SET_ELEM_EXPR`从而使用`gettable(table D)`可以得到`elem->expr->ops`地址，计算出内核基地址

6、再创建一个`bitmap elem`，这样的话`table C`位置上的`bitmap elem`结构体中的`next`指针就会指向刚才创建的`elem`，泄露堆地址

`nft_bitmao_elem`结构体如下

```C
struct nft_bitmap_elem {
	struct list_head	head;
	struct nft_set_ext	ext;
};
```

### 劫持执行流

7、删除步骤6创建的`elem`，然后堆喷`nft_table->udata`占据并布置好fake ops劫持dump函数

8、删除`table D`，继续堆喷`nft_table->udata`占据回来，并且用udata内容修改`table C\D`位置上的`elem->expr->ops`指向第七步伪造的fake ops处

9、dump elem成功劫持执行流

## 注意

在调试过程中，断点下在delesetelem时，运行到deactive发现ext部分只有一个flag位有偏移，其余为0，根据源码是因为它又重新初始化了一个elem，但为什么不用原来的呢？只是为了用后面来赋值

```c
static int nft_setelem_catchall_deactivate(const struct net *net,
					   struct nft_set *set,
					   struct nft_set_elem *elem)
{
	struct nft_set_elem_catchall *catchall;
	struct nft_set_ext *ext;

	list_for_each_entry(catchall, &set->catchall_list, list) {
		ext = nft_set_elem_ext(set, catchall->elem);
		if (!nft_is_active(net, ext))
			continue;

		kfree(elem->priv);
		elem->priv = catchall->elem;   //就是这个
		nft_set_elem_change_active(net, set, ext);
		return 0;
	}

	return -ENOENT;
}
```

